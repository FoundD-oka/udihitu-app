{"ast":null,"code":"// characterData.js\nexport const loadCharacterData = async () => {\n  try {\n    const response = await fetch('/Mac_19_Hitu_Dictionary.txt');\n    if (!response.ok) {\n      throw new Error('Failed to fetch character data');\n    }\n    const text = await response.text();\n    const lines = text.split('\\n');\n    const data = {};\n    lines.forEach(line => {\n      const match = line.match(/\"([^\"]+)\",\"([^\"]+) ([^\"]+)\",\"([^\"]+)\"/);\n      if (match) {\n        const [, reading, kanji, components] = match;\n        data[reading] = {\n          kanji,\n          components: components.split(' ')\n        };\n      }\n    });\n    console.log('Loaded character data:', data);\n    return data;\n  } catch (error) {\n    console.error('Error loading character data:', error);\n    throw error;\n  }\n};\nexport const getRandomCharacter = characterData => {\n  const readings = Object.keys(characterData);\n  if (readings.length === 0) {\n    throw new Error('No character data available');\n  }\n  const randomReading = readings[Math.floor(Math.random() * readings.length)];\n  const {\n    kanji,\n    components\n  } = characterData[randomReading];\n  console.log('Selected random character:', {\n    reading: randomReading,\n    character: kanji\n  });\n  return {\n    reading: randomReading,\n    character: kanji,\n    components\n  };\n};\nexport const getStrokeCount = (char, characterData) => {\n  for (const reading in characterData) {\n    if (characterData[reading].kanji === char) {\n      return characterData[reading].components.length;\n    }\n  }\n  return 0;\n};","map":{"version":3,"names":["loadCharacterData","response","fetch","ok","Error","text","lines","split","data","forEach","line","match","reading","kanji","components","console","log","error","getRandomCharacter","characterData","readings","Object","keys","length","randomReading","Math","floor","random","character","getStrokeCount","char"],"sources":["/Users/m1_mini/Git/udihitu-app/src/characterData.js"],"sourcesContent":["// characterData.js\nexport const loadCharacterData = async () => {\n  try {\n    const response = await fetch('/Mac_19_Hitu_Dictionary.txt');\n    if (!response.ok) {\n      throw new Error('Failed to fetch character data');\n    }\n    const text = await response.text();\n    const lines = text.split('\\n');\n    const data = {};\n\n    lines.forEach(line => {\n      const match = line.match(/\"([^\"]+)\",\"([^\"]+) ([^\"]+)\",\"([^\"]+)\"/);\n      if (match) {\n        const [, reading, kanji, components] = match;\n        data[reading] = { kanji, components: components.split(' ') };\n      }\n    });\n\n    console.log('Loaded character data:', data);\n    return data;\n  } catch (error) {\n    console.error('Error loading character data:', error);\n    throw error;\n  }\n};\n\nexport const getRandomCharacter = (characterData) => {\n  const readings = Object.keys(characterData);\n  if (readings.length === 0) {\n    throw new Error('No character data available');\n  }\n  const randomReading = readings[Math.floor(Math.random() * readings.length)];\n  const { kanji, components } = characterData[randomReading];\n  console.log('Selected random character:', { reading: randomReading, character: kanji });\n  return { reading: randomReading, character: kanji, components };\n};\n\nexport const getStrokeCount = (char, characterData) => {\n  for (const reading in characterData) {\n    if (characterData[reading].kanji === char) {\n      return characterData[reading].components.length;\n    }\n  }\n  return 0;\n};"],"mappings":"AAAA;AACA,OAAO,MAAMA,iBAAiB,GAAG,MAAAA,CAAA,KAAY;EAC3C,IAAI;IACF,MAAMC,QAAQ,GAAG,MAAMC,KAAK,CAAC,6BAA6B,CAAC;IAC3D,IAAI,CAACD,QAAQ,CAACE,EAAE,EAAE;MAChB,MAAM,IAAIC,KAAK,CAAC,gCAAgC,CAAC;IACnD;IACA,MAAMC,IAAI,GAAG,MAAMJ,QAAQ,CAACI,IAAI,CAAC,CAAC;IAClC,MAAMC,KAAK,GAAGD,IAAI,CAACE,KAAK,CAAC,IAAI,CAAC;IAC9B,MAAMC,IAAI,GAAG,CAAC,CAAC;IAEfF,KAAK,CAACG,OAAO,CAACC,IAAI,IAAI;MACpB,MAAMC,KAAK,GAAGD,IAAI,CAACC,KAAK,CAAC,uCAAuC,CAAC;MACjE,IAAIA,KAAK,EAAE;QACT,MAAM,GAAGC,OAAO,EAAEC,KAAK,EAAEC,UAAU,CAAC,GAAGH,KAAK;QAC5CH,IAAI,CAACI,OAAO,CAAC,GAAG;UAAEC,KAAK;UAAEC,UAAU,EAAEA,UAAU,CAACP,KAAK,CAAC,GAAG;QAAE,CAAC;MAC9D;IACF,CAAC,CAAC;IAEFQ,OAAO,CAACC,GAAG,CAAC,wBAAwB,EAAER,IAAI,CAAC;IAC3C,OAAOA,IAAI;EACb,CAAC,CAAC,OAAOS,KAAK,EAAE;IACdF,OAAO,CAACE,KAAK,CAAC,+BAA+B,EAAEA,KAAK,CAAC;IACrD,MAAMA,KAAK;EACb;AACF,CAAC;AAED,OAAO,MAAMC,kBAAkB,GAAIC,aAAa,IAAK;EACnD,MAAMC,QAAQ,GAAGC,MAAM,CAACC,IAAI,CAACH,aAAa,CAAC;EAC3C,IAAIC,QAAQ,CAACG,MAAM,KAAK,CAAC,EAAE;IACzB,MAAM,IAAInB,KAAK,CAAC,6BAA6B,CAAC;EAChD;EACA,MAAMoB,aAAa,GAAGJ,QAAQ,CAACK,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAGP,QAAQ,CAACG,MAAM,CAAC,CAAC;EAC3E,MAAM;IAAEV,KAAK;IAAEC;EAAW,CAAC,GAAGK,aAAa,CAACK,aAAa,CAAC;EAC1DT,OAAO,CAACC,GAAG,CAAC,4BAA4B,EAAE;IAAEJ,OAAO,EAAEY,aAAa;IAAEI,SAAS,EAAEf;EAAM,CAAC,CAAC;EACvF,OAAO;IAAED,OAAO,EAAEY,aAAa;IAAEI,SAAS,EAAEf,KAAK;IAAEC;EAAW,CAAC;AACjE,CAAC;AAED,OAAO,MAAMe,cAAc,GAAGA,CAACC,IAAI,EAAEX,aAAa,KAAK;EACrD,KAAK,MAAMP,OAAO,IAAIO,aAAa,EAAE;IACnC,IAAIA,aAAa,CAACP,OAAO,CAAC,CAACC,KAAK,KAAKiB,IAAI,EAAE;MACzC,OAAOX,aAAa,CAACP,OAAO,CAAC,CAACE,UAAU,CAACS,MAAM;IACjD;EACF;EACA,OAAO,CAAC;AACV,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}